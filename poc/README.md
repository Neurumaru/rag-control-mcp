# PoC 진행 계획 보고서

## 1. PoC 목표

본 PoC(Proof of Concept) 계획의 목표는 `mcp-rag-control` 프로젝트의 핵심 아키텍처 요소들, 즉 ▲기본 RAG 파이프라인, ▲분리된 데이터 소스 연동을 위한 MCP(Model Context Protocol) 인터페이스, ▲에이전트 기반 제어 로직(LangGraph 활용), ▲중앙 오케스트레이션 컨트롤러의 기술적 타당성과 구현 가능성을 단계별로 검증하는 것입니다. 각 PoC 단계는 가능한 독립적으로 개발 및 테스트하여 점진적인 통합과 위험 관리가 용이하도록 설계되었습니다.

## 2. PoC 단계별 계획

### PoC 1: 기본 RAG 파이프라인 구현

*   **목표:** 간단한 텍스트 문서를 로드하여 기본적인 RAG(검색 → 증강 → 생성) 파이프라인을 로컬 환경에서 실행하고 검증합니다. 핵심 RAG 로직의 기본적인 동작을 확인합니다.
*   **기술:** Python, LlamaIndex 또는 LangChain, 로컬 임베딩 모델 (예: `sentence-transformers`), 로컬 벡터 저장소 (예: ChromaDB 또는 FAISS local), 로컬 LLM (예: Ollama + Llama3) 또는 OpenAI API.
*   **주요 작업:**
    *   문서 로딩 및 청킹(Chunking) 구현.
    *   텍스트 임베딩 및 로컬 벡터 저장소 저장/검색 구현.
    *   검색된 컨텍스트를 포함하여 LLM 프롬프트 구성 및 호출.
    *   질문-답변 테스트를 통한 RAG 파이프라인 검증.
*   **성공 기준:**
    *   입력 질문에 대해 문서 내 관련 구절을 성공적으로 검색.
    *   검색된 컨텍스트를 기반으로 LLM이 의미론적으로 관련된 답변을 생성.
    *   독립 실행형 Python 스크립트로 실행 가능.
*   **독립성:** 외부 MCP나 복잡한 서버 설정 없이 RAG의 핵심 로직을 독립적으로 검증합니다.

### PoC 2: 벡터 검색 MCP 연동 (FAISS)

*   **목표:** FAISS 서버(Docker 사용 권장)를 구축하고, 간단한 API(Flask/FastAPI)를 통해 벡터 검색 기능을 제공하는 '벡터 검색 MCP'를 구현합니다. PoC 1의 로컬 검색 로직을 이 MCP 호출로 대체하여, 분리된 벡터 저장소와의 연동을 검증합니다.
*   **기술:** Python, FAISS, Docker, Flask/FastAPI, PoC 1 결과물 (클라이언트 로직 수정).
*   **주요 작업:**
    *   Docker 기반 FAISS 서버 설정 및 실행.
    *   벡터 추가, 검색 등의 기능을 제공하는 MCP API 엔드포인트 구현 (명확한 입출력 형식 정의 - 예: JSON).
    *   PoC 1의 RAG 스크립트에서 로컬 벡터 저장소 대신 MCP API를 호출하도록 수정.
    *   API 연동 및 검색 결과 검증.
*   **성공 기준:**
    *   독립적으로 실행되는 벡터 검색 MCP 서버.
    *   MCP API를 통해 벡터 검색 요청(예: top-k 유사 벡터 검색)이 성공하고, 예상되는 형식의 결과를 반환 (예: 100ms 이내 응답).
    *   수정된 RAG 클라이언트가 MCP를 통해 검색을 성공적으로 수행.
*   **독립성:** RAG 파이프라인과 벡터 저장소의 물리적/논리적 분리를 검증하고, 표준화된 MCP 인터페이스를 통한 상호작용을 시험합니다.

### PoC 3: 지식 그래프 MCP 연동 (Neo4j)

*   **목표:** Neo4j 서버(Docker 사용 권장)에 간단한 지식 그래프(예: 문서-엔티티-키워드 관계)를 구축하고, MCP 인터페이스(API)를 통해 그래프 쿼리(Cypher) 기능을 제공하는 '지식 그래프 MCP'를 구현합니다. 그래프 DB 연동 및 MCP 인터페이스 유효성을 검증합니다.
*   **기술:** Python, Neo4j, Docker, Flask/FastAPI, Cypher.
*   **주요 작업:**
    *   Docker 기반 Neo4j 서버 설정 및 실행.
    *   샘플 데이터로 지식 그래프 구축 (예: 문서 노드, 엔티티 노드, 관계).
    *   Cypher 쿼리 실행 기능을 제공하는 MCP API 엔드포인트 구현 (명확한 입출력 형식 정의).
    *   간단한 클라이언트 스크립트를 작성하여 MCP API 호출 및 결과 검증.
*   **성공 기준:**
    *   독립적으로 실행되는 지식 그래프 MCP 서버.
    *   MCP API를 통해 특정 Cypher 쿼리(예: 특정 문서와 연결된 엔티티 조회)가 성공하고, 예상되는 그래프 데이터를 반환.
*   **독립성:** 그래프 데이터베이스 연동 방식과 MCP 인터페이스의 유효성을 RAG 파이프라인과 별개로 검증합니다.

### PoC 4: 에이전트 RAG 워크플로우 (LangGraph)

*   **목표:** LangGraph를 사용하여 복잡한 질문에 대응하는 에이전트 워크플로우(상태 머신/그래프)를 구현합니다. 이 에이전트는 질문 유형이나 중간 결과에 따라 PoC 2의 벡터 검색 MCP와 PoC 3의 지식 그래프 MCP 클라이언트를 조건부로 호출하거나, 두 결과를 종합하여 최종 답변 컨텍스트를 생성합니다. 복잡한 제어 흐름 및 에이전트 로직 구현 가능성을 검증합니다.
*   **기술:** Python, LangGraph, PoC 2/3 결과물(MCP 클라이언트 로직 활용).
*   **주요 작업:**
    *   LangGraph를 사용하여 상태 노드 및 엣지(조건부 분기 포함) 정의.
    *   각 노드에서 적절한 MCP 클라이언트 호출 로직 구현.
    *   여러 MCP의 결과를 통합하고 처리하는 로직 구현.
    *   다양한 질문 유형에 대한 워크플로우 실행 테스트.
*   **성공 기준:**
    *   입력 질문에 따라 정의된 워크플로우 경로(예: 벡터 검색만 수행, 그래프 검색만 수행, 둘 다 수행 후 통합)를 정확히 실행.
    *   여러 소스(벡터, 그래프)의 정보를 성공적으로 통합하여 최종 컨텍스트 생성.
*   **독립성:** LangGraph를 이용한 복잡한 제어 흐름과 에이전트 로직 구현 가능성을 검증합니다. 기존에 구현된 MCP 인터페이스를 활용합니다.

### PoC 5: 통합 MCP 인터페이스 및 기본 오케스트레이션

*   **목표:** PoC 2, 3에서 구현한 개별 MCP 서버들을 논리적으로 통합하고, 외부 요청(예: `/execute` API 엔드포인트)을 받아 적절한 RAG 파이프라인(PoC 1의 기본 RAG 또는 PoC 4의 에이전트 RAG)을 실행시키는 중앙 컨트롤러(간단한 오케스트레이션 로직 포함)를 구현합니다. 초기 시스템 통합 및 중앙 제어 기능을 검증합니다.
*   **기술:** Python, Flask/FastAPI, PoC 1/2/3/4 결과물.
*   **주요 작업:**
    *   `/execute` 등 주요 API 엔드포인트를 가진 중앙 컨트롤러 서버 구현.
    *   입력 요청 분석 및 실행할 파이프라인(기본 RAG vs 에이전트 RAG) 결정 로직 구현 (초기에는 간단한 규칙 기반, 추후 확장 고려).
    *   선택된 파이프라인 실행 및 관련 MCP들과의 상호작용 관리.
    *   최종 결과를 클라이언트에게 반환하는 로직 구현.
    *   간단한 종단 간(End-to-End) 테스트 시나리오 실행.
*   **성공 기준:**
    *   단일 `/execute` 엔드포인트를 통해 요청을 전달하면, 컨트롤러가 적절한 파이프라인(기본 또는 에이전트)을 선택하여 실행.
    *   선택된 파이프라인이 필요한 MCP들과 성공적으로 통신하고 최종 응답을 생성하여 반환.
*   **독립성:** 개별 PoC 컴포넌트들을 연결하여 전체 아키텍처의 초기 형태를 검증하고, 중앙 컨트롤러의 기본 기능을 확인합니다.

## 3. 주요 고려 사항 및 교차 작업

ChatGPT의 리뷰를 바탕으로 PoC 진행 전반에 걸쳐 다음 사항들을 고려하고 수행합니다.

*   **명확한 인터페이스 정의 (API 계약):** 각 MCP(PoC 2, 3) 및 중앙 컨트롤러(PoC 5)의 API 입출력 형식, 데이터 타입, 상태 코드, 오류 코드 등을 명확히 정의하고 문서화합니다. 이는 PoC 단계 간의 원활한 통합을 보장합니다. (예: OpenAPI/Swagger 활용 고려)
*   **컨테이너화 활용:** PoC 2(FAISS), PoC 3(Neo4j) 등 외부 서비스는 Docker를 사용하여 환경을 구성합니다. 이는 재현성을 높이고 개발/테스트 환경 격리를 돕습니다.
*   **테스트 전략:** 각 PoC 단계별 단위 테스트 및 통합 테스트 계획을 수립합니다. 외부 서비스(LLM API, MCP 서버 등)에 대한 모의(Mock) 객체 또는 스텁(Stub)을 사용하여 독립적인 테스트 환경을 구축합니다.
*   **로깅 및 모니터링:** 초기 단계부터 각 컴포넌트(특히 MCP 인터페이스 및 컨트롤러)에 기본적인 로깅(요청/응답, 오류 등)을 추가하여 디버깅 및 통합 과정을 용이하게 합니다.
*   **지속적인 문서화:** 각 PoC 진행 과정에서 발견된 사항, 구현 결정, API 계약 등을 지속적으로 문서화합니다 (`poc/{concept}/README.md` 등 활용).
*   **기능 플래그 (선택 사항):** PoC 5 단계에서 기본 RAG(PoC 1 기반)와 에이전트 RAG(PoC 4 기반)를 전환할 수 있는 간단한 설정이나 기능 플래그 도입을 고려하여 유연성을 확보합니다.

## 4. 다음 단계

1.  `poc/` 디렉토리를 생성합니다. (완료)
2.  본 보고서 내용을 `poc/README.md` 파일로 저장합니다. (진행 중)
3.  PoC 1: 기본 RAG 파이프라인 구현을 시작합니다. (`poc/basic_rag/` 디렉토리 생성 및 작업 진행)

--- 